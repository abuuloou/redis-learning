# 缓存预热

## 问题

服务器启动之后迅速宕机了

## 排查

请求数量较高

主从之间数据吞吐量加大，数据同步操作频度较高

## 解决方案

前置准备工作:
1．日常例行统计数据访问记录，统计访问频度较高的热点数据
2．利用LRU数据删除策略，构建数据留存队列
			例如:storm与kafka配合
准备工作:
3.将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据
4.利用**分布式多服务器同时**进行数据读取，提速数据加载过程
实施:
1．使用脚本程序固定触发数据预热过程
2．如果条件允许，使用了CDN(内容分发网络)，效果会更好

## 总结

缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题!用户直接查询事先被预热的缓存数据!

# 缓存雪崩

## 数据库服务器崩溃

1.系统平稳运行过程中，忽然数据库连接量激增
2.应用服务器无法及时处理请求
3.大量408，500错误页面出现
4.客户反复刷新页面获取数据
5.数据库崩溃
6.应用服务器崩溃
7.重启应用服务器无效
8.Redis服务器崩溃
9.Redis集群崩溃
10.重启数据库后再次被瞬间流呈放倒



## 问题排查

1.在一个**较短**的时间内，缓存中**较多**的key**集中过期**。短时间内部分缓存失效了。
2.此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据。
3.数据库同时接收到**大量**的请求无法及时处理
4.**Redis大量请求被积压，开始出现超时现象**
5.数据库流量激增，数据库崩溃
6.重启后仍然面对缓存中无数据可用
7.Redis服务器资源被严重占用，Redis服务器崩溃
8.Redis集群呈现崩塌，集群瓦解
9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃
10.应用服务器，redis，数据库全部重启，效果不理想。无法改变大量请求缓存没了无法响应。



## 方案（平时如何设计）

1.更多的页面静态化处理

2.构建多级缓存架构

- Nginx缓存+redis缓存+ehcache缓存

3.检测Mysql严重耗时业务进行优化

- 对数据库的瓶颈排查:例如超时查询、耗时较高事务等

4.灾难预警机制

- 监控redis服务器性能旨标

  CPU占用、CPU使用率

  内存容量

  查询平均响应时间

  线程数

5．限流、降级(客户端)

- 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问

## 方案（针对问题动什么东西）

1.LRU与LFU切换

2.数据有效期策略调整

- 根据业务数据有效期进行**分类错峰**，A类90分钟，B类80分钟，C类70分钟

- 过期时间使用固定时间**+随机值**的形式，稀释集中到期的key的数呈

3.超热数据使用永久key

4.定期维护(自动+人工)

- 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时(如果访问量高那就延时)

5.加锁

​		慎用!

## 总结

缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现(约40%)，配合其他策略─起使用，并监控服务器的运行数据，根据运行记录做快速调整。

![image-20201009212716013](D:\Users\74178\AppData\Roaming\Typora\typora-user-images\image-20201009212716013.png)

# 缓存击穿

## 数据库服务器崩溃

1.系统平稳运行过程中
2.数据库连接呈瞬间激增
3.Redis服务器无大量key过期
4.Redis内存平稳，无波动
5.Redis服务器CPU正常
6.数据库崩溃

## 问题排查

1.Redis中某个key过期，该key访问量巨大
2.多个数据请求从服务器直接压到Redis后，均未命中
3.Redis在短时间内发起了大量对数据库中同一数据的访问

## 问题分析

单个key高热数据
key过期

## 解决方案（术）

1.预先设定（预先排除一些）

- 以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长
  注意:购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势

2现场调整

- 监控访问量，对**自然流呈激增**的数据延长过期时间或设置为永久性key

3.后台刷新数据

- 启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失

4.二级缓存

- 设置不同的失效时间，保障**不会被同时淘汰就行**

5.加锁

- 分布式锁，防止被击穿，但是要注意也是**性能瓶颈**，慎重!



## 总结

缓存击穿就是**单个高热数据过期的瞬间**，数据访问虽较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。

# 缓存穿透

## 数据库服务器崩溃

1.系统平稳运行过程中
2.应用服务器流量随时间增量较大
3.Redis服务器命中率随时间逐步降低
4.Redis内存平稳，内存无压力
5.Redis服务器CPU占用激增
6.数据库服务器压力激增
7.数据库崩溃

## 问题排查

Redis中大面积出现未命中
出现**非正常URL**访问

## 问题分析

获取的数据在数据库中也不存在，数据库查询未得到对应数据
Redis获取到null数据未进行持久化，直接返回
下次此类数据到达重复上述过程
出现黑客攻击服务器（像让你瘫痪，让你无法命中，服务器压力太大了）

## 解决方案（术）

1.缓存null

- 对查询结果为null的数据进行缓存（长期使用，定期清理)，设定短时限，例如30-60秒，最高5分钟。同时来几十万个请求null全缓存起来也不实现，对内存不好，只是用来缓解穿透，临时的一个操作。

2.白名单策略

- 提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放
  行，加载异常数据时直接拦截〔效率偏低)。id放在bitmaps集合里，然后呢在里面放行，不在拦截，效率低
- 使用布隆过滤器〔有关布隆过滤器的命中问题对当前状况可以忽略)不可能百分百匹配成功

3.实施监控

- 实时监控redis命中率(业务正常范固时，通常会有一个波动值）与null数据的占比

  非活动时段波动:通常检测3-5倍，超过5倍纳入重点排查对象

  活动时段波动:通常检测10-50倍，超过50倍纳入重点排查对象

  根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营)

4.key加密

- 问题出现后，临时启动防灾业务key，**对key进行业务层传输加密服务**，设定校验程序，过来的key校验。key校验都不过就GG。

  例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问

  白名单有个比对的过程，这个比对过程更复杂

## 总结

缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。

bitmaps拦在redis和服务器中间

加密key拦到应用服务器

**无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。**

# 性能指标监控

## 性能指标:Performance

| Name                      | Description                                                  |
| ------------------------- | ------------------------------------------------------------ |
| latency                   | Redis响应一个请求的时间，处理时长                            |
| instantaneous_ops_per_sec | 平均每秒处理请求总数                                         |
| hit rate(calculated)      | 缓存命中率（计算出来的）缓存命中率低服务器请求压力大。看key的过期策略，会受一点影响。 |

## 内存指标: Memory

| Name                   | Description                                                  |
| ---------------------- | ------------------------------------------------------------ |
| userd_memory           | 已使用内存【内存爆没爆】                                     |
| mem_frgmentation_ratio | 内存碎片率                                                   |
| evicted_keys           | 由于最大内存限制被移除的key的数量【删除策略，影响命中】      |
| blocked_clients        | 由于BLPOP,BRPOP,or BRPOPLPUSH而备阻塞的客户端【阻塞的量大要小心】 |

## 基本活动指标: Basic activity

| Name                       | Description                                                  |
| -------------------------- | ------------------------------------------------------------ |
| connected_clients          | 客户端链接数                                                 |
| connected_slaves           | slave数量                                                    |
| master_last_io_seconds_ago | 最近一次主从交互之后的秒数【过长，检查从的网络环境。如果大量的从，看看主的网络】 |
| keyspace                   | 数据库中的key值总数                                          |

## 持久性指标:Persistence

灾难恢复

| Name                        | Description                                        |
| --------------------------- | -------------------------------------------------- |
| rdb_last_save_time          | 最后一次持久化保存到磁盘的时间戳【丢的数据了】     |
| rdb_changes_since_last_save | 自最后一次持久化以来数据库的更改数【变化的数据量】 |

## 错误指标:Error

| Name                           | Description                                                  |
| ------------------------------ | ------------------------------------------------------------ |
| rejected_connections           | 由于达到maxclient限制而被拒绝的连接数【redis对外提供服务的有效率】 |
| keyspace_misses                | Key值查找失败（没有命中次数）【雪崩，击穿，穿透】            |
| master_link_down_since_seconds | 主从断开的持续时间（以秒为单位）【决定了单点时间服务器的压力】 |

# 性能指标监控命令

## 一些工具

- Cloud Insight Redis
- Prometheus
- Redis-stat
- Redis-faina
- RedisLive
- zabbix

## benchmark

命令

```
redis-benchmark[-h] [-p] [-c]  [-n <requests]> [-k ]
```

范例1

```
redis-benchmark
说明:50个连接，10000次请求对应的性能
```

范例2

```
redis-benchmark -c 100 -n 5000
说明:100个连接，5000次请求对应的性能
```



```
[root@VM-0-7-centos redis-4.0.0]# redis-benchmark
====== PING_INLINE ======
  100000 requests completed in 0.88 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.82% <= 1 milliseconds
99.62% <= 2 milliseconds
99.95% <= 3 milliseconds
100.00% <= 3 milliseconds
114155.25 requests per second

====== PING_BULK ======
  100000 requests completed in 1.11 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

97.76% <= 1 milliseconds
98.33% <= 2 milliseconds
98.61% <= 3 milliseconds
98.70% <= 5 milliseconds
99.38% <= 6 milliseconds
99.77% <= 7 milliseconds
99.89% <= 8 milliseconds
99.96% <= 9 milliseconds
99.97% <= 10 milliseconds
100.00% <= 10 milliseconds
89928.05 requests per second

====== SET ======
  100000 requests completed in 0.92 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

99.13% <= 1 milliseconds
99.60% <= 2 milliseconds
99.65% <= 3 milliseconds
99.84% <= 4 milliseconds
99.85% <= 5 milliseconds
99.95% <= 7 milliseconds
99.96% <= 8 milliseconds
100.00% <= 8 milliseconds
108695.65 requests per second

====== GET ======
  100000 requests completed in 0.88 seconds
  50 parallel clients
  3 bytes payload
  keep alive: 1

98.73% <= 1 milliseconds
99.59% <= 2 milliseconds
99.95% <= 3 milliseconds
99.97% <= 12 milliseconds
100.00% <= 12 milliseconds
114285.71 requests per second

```

## monitor

```
monitor
打印服务器调试信息

redis-cli
monitor

```

![image-20201009222550692](D:\Users\74178\AppData\Roaming\Typora\typora-user-images\image-20201009222550692.png)



## slowlog

slowlog   redis维护了一块空间，帮助你存储现在执行比较慢的一些信息，前提是比较慢

```
slowlog [operator]
get		获取慢查询入职
len		获取慢查询日志条目数
reset	重置慢查询日志
```



相关配置

```
slowlog-log-slower-than 1000   #设置慢查询的时间下限，单位：微秒
slowlog-max-len 100    #设置慢查询命令对应的日志显示长度，单位：命令数
```

